\documentclass[8pt]{extarticle}
\usepackage{extsizes}
\usepackage{fullpage}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{cite}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{alltt}
\title{Experimentation Project}
\author{Ernesto Rodriguez}
\begin{document}
\maketitle
\section{Introduction}
This document describes the implementation of the analysis named: "Polyvariant Flow Analysis with Higher-ranked Polymorphic Types and Higher-order Effect Operators". This is a flow analysis for a higher order language which uses higher-ranked types to increase the presicion. The result of the analysis is delivered as an annotated type system for a simply typed lambda calculus. The major limitation of the analysis is that it does not support polymorphic types.
\\\\
The analysis has been implemented in the Haskell programming language and also includes an interactive web interface that can be compiled using GHCJS\cite{GHCJS}. Alternatively, the analysis can be compiled with the GHC compiler and the input is read form the standard input and the ouput is a Latex document with the results of the analysis.
\section{File Structure}
The code is divided in three modules: algorithms, types and web. The web group only contains details about manipulating dom elements and interfacing with the other two containers so it is not interesting and will not be explained any futher.
\section{Types}
This module defines all the types that were defined to model the analysis. This ammounts to:
\begin{itemize}
\item A type for the lambda calculus (LambdaCalc.hs)
\item A type for simple types (Type.hs)
\item A type for annotated types (AnnType.hs)
\item A type for effects (Effect.hs)
\item A type for annotations (Annotation.hs)
\item A type for Sorts (Sorts.hs)
\end{itemize}
Additionally, the module contains the \verb+Common+ component which defines algorithms that operates in many of those types.
\subsection{Traversals}
Tree traversals over the mentioned types are defined as folds. The \verb+Common+ component provides a type class called \verb+Fold+ which defines the necessary methods for basic traversal over a structure. This includes a function to fold over the structure and two algebras: the regular algebra and the group algebra. The fold function is expected to provide a unique index to all elements of the structure and the functions of each of the algebras always take as a first argument that index. All maps that indexed by integers used in this implementation use this unique identifier as their index.
\\\\
Algebras are parametrized by three types: \verb+alg m s r+. The \verb+m+ parameter is the monad under which the algebra operates. The \verb+s+ parameter is the type of the structure the algebra is meant to traverse and the \verb+r+ parameter is the type of the state and result of a fold that uses such algebra.
\\\\
The {\bf regular algebra} is meant for either manipulating the three or performing some effectful computation while traversing the tree. The result or state of of folds that use that algebra are of the same type as the structure they traverse (ie. they are of type \verb+alg m s s+). The most common use of the algebra is performing applications or substitutions. The function \verb+baseAppAlg+ defines an algebra that performs application to a lambda calculus like term.
\\\\
The {\bf group algebra} is meant to collect results from a catamorphism. The \verb+Group+ typeclass as defined in this component is equivalent to a monoid. It defines an operation to join to elements of the group and an empty element. The most common use of this algebra is with maps. Since the index of each component dosen't change from fold to fold, a traversal can save local results in a map and look them up in subsequent traversals.
\\\\
The first refinement of \verb+Fold+ is the type class \verb+WithAbstraction+. This type class models structures that can define scoped variables. Variables in this implementation are represented by integer values. The \verb+increment+ method of the class increments every variable by the specified ammount. Details about the importance of the function will come later. It also defines the method \verb+abst+ which serves to pattern match abstraction elements of the structure and the method \verb+abstC+ that serves to build abstractions of that structure.
\\\\
The \verb+LambdaCalculus+ class is a refinement of the \verb+WithAbstraction+ class. In addition to abstractions, structures that belong to this class also have variable occurences and applications. As before, it provides the methods \verb+app+, \verb+appC+, \verb+var+, \verb+varC+ to pattern match and construct application and variables. The algebras are extedned in a similar fashion.
\\\\
The final refinement is the \verb+WithSets+ class. This is the class of structures that contain sets. A set is modelled as an empty set and a union that joins elements to increase the size of the set. Additionally, the class can also have a case that contains a set of structures. This is a convenience facility for efficiency and to make comparison of elements easier. When the structure is being traversed by the \verb+foldM+ method, it is expected that this method un-packs the set case into a sequence of unions. Algebras over theese structures should make no assumptions on how the un-wrapping is done except that elements of the same set will be connected by unions. The algebra for theese structures does not contain a special case for the set branch since it should get converted to unions and handled as it were an union case.
\subsection{Equality, Ordering and Normalization of Structures}
The analysis requires certain operations to be defined in strucutres. Since it checks for type equality based on certain equality rules and defines algorithms under the assumption that types will be of a particular structure. The first requirement is some notion of structural equality. This is achieved by:
\begin{itemize}
\item Having a uniform naming convention for variables.
\item Having an ordering defined for elements and ensure that the unions or sets are always ordered with respect to that ordering.
\end{itemize}
The uniform nameing convention is achieved by nameing each variable according to the number of abstraction nestings that occur until the abstraction that introduces the variable. The depth of the abstractions that occur in a term are defined as follows:
\begin{lstlisting}[
  mathescape,
  columns=fullflexible,
  basicstyle=\fontfamily{lmvtt}\selectfont,
]
  depths $(\lambda x.t)$ = $\{\lambda x.t\ \to\ 1\}\ \cup\ \{t'\ \to\ d + 1\ |\ (t'\ \to\ d + 1)\ \in$ depths $t\}$
  depths $(t_1\ t)$ = depths $t_1\ \cup$ depths $t$
  depths $x$ = $\emptyset$
\end{lstlisting}
Using this notion of depth of an abstraction, it is possible to define a nameing convention where the name of a variable is always the depth of the abstraction where it was introduced. With this notion in place, care must be taken when performing applications since an application changes the depht of all variables inside the terms being applied. To perform applications, first an auxiliary function \verb+increment+ is defined (which is the same as the one in the \verb+WithAbstraction+ type class):
\begin{lstlisting}[
  mathescape,
  columns=fullflexible,
  basicstyle=\fontfamily{lmvtt}\selectfont,
]
  increment i t = increment' t
    where
      increment' $(\lambda x.t)$ = $\lambda (x+i).$ increment' $t$
      increment' $(t_1 t)$ = (increment' $t_1$) (increment' $t$)
      increment' $x$ when $x \in$ freeVariables(t) = x
      increment' $x$ = x + i
\end{lstlisting}
A basic algebra that performs this increment is is provided in the \verb+Analysis.Types.Common+ package and is called \verb+baseIncAlg+. This algebra implements the common requirements for a lambda calculus and can be extended to handle more complex structures. Now assuming that one has two terms \verb+t1+ and \verb+t2+ with all variables named according to the depth of the binder where they wehere introduced. The application \verb+t1 t2+ is performed by:
\begin{enumerate}
\item Incrementing the variables of \verb+t2+ by one
\item Perfroming the application (as usual)
\item Decrementing the variables of the result by one
\end{enumerate}
This notion of application allows lambda terms to be named according to the depths and then perform reductions such that terms will reduce to the same terms. It is still the case that terms containing unions have to be ordered in some uniform way to perform equality checks. Fortunately, using the derived \verb+Ord+ instance from GHC, the ordering works as needed. This is evidenced by the tests included in the package Analysis.Types which live in the folder test.
\\\\
To sumarize, the normal form of a term is obtained by:
\begin{enumerate}
\item Re-naming the variables according to the naming convention discussed above
\item Reducing the term until a fixpoint is found
\item Grouping all unions that appear in the term inside a Set (from \verb+Data.Set+)
\end{enumerate}
\subsection{Reduction}
The addition of sets to the language requries a couple of extra reduction rules to ensure normal forms are indeed unique. Theese rules are implemented in \verb+Analysis.Types.Common+ package by the algebra \verb+baseRedUnionAlg+. Below they are defined:
\begin{lstlisting}[
  mathescape,
  columns=fullflexible,
  basicstyle=\fontfamily{lmvtt}\selectfont,
]
  (t1 $\cup$ t2) t3 $\rightarrow$ (t1 t3 $\cup$ t2 t3)
  ($\lambda$ x . t1) $\cup$ ($\lambda$ x . t2) $\rightarrow$ $\lambda$ x . t1 $\cup$ t2
\end{lstlisting}
Since the language contains sets, one must ensure that ordering of the elements of the set does not matter. In other words, the elements of a set must always be ordered in a uniform way. To achieve this, the derived \verb+Eq+ instance and the structure \verb+Data.Set+ are used. For this, the algebra \verb+unions+ is defined in \verb+Analysis.Types.Common+. This algebra traverses a structure and combines all elements connected by unions into a single set. This is the reason why the types \verb+Annotation+ and \verb+Effect+ contain a constructor named \verb+Set+. As mentioned above, the folds for each of the elements re-write theese sets as sequences of unions.
\\\\
The final ingredient of reductions is performing applications as mentioned in the section above.
\\\\
\section{Algorithms}
The algorithms for the analysis are defined as algebras which are then used to traverse the structure. The four main algorithms are:
\begin{enumerate}
\item The completion algorithm (\verb+Analysis.Algorithms.Completion+).
\item The instantiation algorithm (\verb+Analysis.Algorithms.Instantiation+).
\item The join algorithm (\verb+Analysis.Algorithms.Join+).
\item The matching algorithm (\verb+Analysis.Algorithms.Match+).
\item The reconstruction algorithm (\verb+Analysis.Algorithms.Reconstruction+).
\item The constraint solver (\verb+Analysis.Algorithms.Solve+).
\end{enumerate}
Additionally, the package \verb+Analysis.Algorithms.Common+ contains code which is common to all the algorithms. The following sections explain details on how theese algorithms were implemented.
\subsection{Common}
In this package, mostly structures for bookeeping the different stages of the algorithm are defined. The structure \verb+RState+ is used to store the value of variables created at different stages of the reconstruction algorithm. It contains three fields:
\begin{itemize}
\item \verb+freshFlowVars+ map that contains the identifiers assigned to the $\beta_1$ variables of the reconstruction algorithm. This is necessary because the variable is used as argument for a recursive call so all atoms of the \verb+LambdaCalc+ need access to its value.
\item \verb+completions+ map that contains the value that results from calling the completion algorithm in the abstraction branch. The result of the completion is added to the environment and used in recursive calls. However, this map is not entirely necessary since the value could be recovered from the environment but it is defined for convenience.
\item \verb+gammas+ This contains the value of the environment $\Gamma$ at every point in the reconstruction algorithm.
\end{itemize}
The values of the components of this strucutre are intialized by the functions \verb+calcCompletions+ and \verb+calcGammas+ of the module \verb+Analysis.Algorithms.Reconstruction+.
The \verb+RContext+ structure is used as the state of the state monad where the reconstruction algorithm is being executed. It contains the fields:
\begin{itemize}
\item \verb+freshIx+ this field contains the value of the latest index that was given to a fresh variable. Fresh variables are always given a negative index and every time a new fresh variable is demanded, the value of this field is decreased by one.
\item \verb+fvGammas+ this field contains a map which stores the sort that has been given to every fresh variable created at any stage of the algorithm
\item \verb+history+ at every step of the reconstruction alorithm, the value that was assigned to all the variables present in that step is saved in this field. This allows easier inspection on how the final result was obtained.
\end{itemize}
The reconstruciton algorithm also contains an Exception monad to handle cases when an incorrectly typed lambda term is analyzed. To nicely display error messages, the \verb+FailureElement+ type is used. Details about this type are very technical because it is simply a choice type with many branches. The type is defined this way so different rendering mechanisms can display errors in the most suitable way.
\subsection{Reconstruction}
The algorithm is implemented very similarly as it is described in the paper. It is divided in three stages, namely \verb+calcGammas+, \verb+calcCompletions+ and \verb+reconstructionF+ which perform the steps indicated above. It includes a logging and error reporting facility. The log contains a list of values for all the variables that are defined in the pseudo-code algorithm of the original paper. Since this implementation performs a particular normalization, the log also includes the values of the variables before normalizations were applied. After the algorithm completes, a final constraint solving step is invoked to obtain the final annotation for the type and the set of effects that have been obtained for the type.
\\\\
With the algorithm as described in the original paper, the author did not manage to produce a successful implementation to analyzie fixpoints. Below the problems encountered are described and later the solution the author implement in this version of the algorithm. If the implementation as described in the original paper is desired, the program can be compiled with the CPP flag ``-DNoFixWorkaround''. This is the version used to show the problems.
\\\\
The first problem is that free variables are produced as a result of replacing a variable with itself during the matching phase of the fix case. Consider the expression:
\[
\left(\left(\mathbf{fix}\;{}\left(\lambda{}x^{1}:\mathtt{B}\to{}\mathtt{B}\;{}.\;{}\left(\lambda{}x^{2}:\mathtt{B}\;{}.\;{}\left(\mathbf{if}\;{}x^{2}\;{}\mathbf{then}\;{}\left(x^{1}*\left(\mathbf{False}\right)^{\mathit{@8}}\right)^{\mathit{@6}}\;{}\mathbf{else}\;{}\left(\mathbf{True}\right)^{\mathit{@9}}\right)^{\mathit{@4}}\right)^{\mathit{@3}}\right)^{\mathit{@2}}\right)^{\mathit{@1}}*\left(\mathbf{True}\right)^{\mathit{@10}}\right)^{\mathit{@0}}
\]
and its resulting type and effects (without the additions:
\[
\begin{array}{c}
\tau=\mathtt{B}^{\left\{\beta{}^{-25}*\left\{\right\};\;{}\textbf{@9};\;{}\beta{}^{-25}*\textbf{@8}\right\}} \\
\phi=\left\{\left(\textbf{@0},\textbf{@3}\right);\;{}\left(\textbf{@1},\textbf{@2}\right);\;{}\left(\textbf{@4},\textbf{@10}\right);\;{}\left(\textbf{@6},\textbf{@3}\right);\;{}\delta{}^{-24}*\textbf{@8}\right\}
\end{array}
\]
When the fixpoint is being analyzied. The first step is a recursive call to the reconstruction algorithm to obtain the type of the underlying lambda. This results in:
\[
\begin{array}{c}
\forall{}\beta{}^{1}:\mathtt{A}\;{}.\;{}\forall{}\delta{}^{2}:\mathtt{A}\to{}\mathtt{E}\;{}.\;{}\forall{}\beta{}^{3}:\mathtt{A}\to{}\mathtt{A}\;{}.\;{}\left(\left(\forall{}\beta{}^{4}:\mathtt{A}\;{}.\;{}\left(\left(\mathtt{B}\right)^{\beta{}^{4}}\right)\xrightarrow{\delta{}^{2}*\beta{}^{4}}\left(\mathtt{B}\right)^{\beta{}^{3}*\beta{}^{4}}\right)^{\beta{}^{1}}\right)\\
\xrightarrow{\left\{\right\}}\left(\forall{}\beta{}^{4}:\mathtt{A}\;{}.\;{}\left(\left(\mathtt{B}\right)^{\beta{}^{4}}\right)\xrightarrow{\left\{\left(\textbf{@4},\beta{}^{4}\right);\;{}\left(\textbf{@6},\beta{}^{1}\right);\;{}\delta{}^{2}*\textbf{@8}\right\}}\left(\mathtt{B}\right)^{\left\{\beta{}^{3}*\left\{\right\};\;{}\textbf{@9};\;{}\beta{}^{3}*\textbf{@8}\right\}}\right)^{\textbf{@3}}
\end{array}
\]
Important to note is that it has the $\beta^3$ and $\delta^2$ variable quantified. Since this is a function that takes as first argument a function and then uses that function in its body (the application labeled {\bf @6}), the $\beta^3$ and $\delta^2$ can be substitued according to the function provided in the first argument. Such substitution must also appear in the resulting value and effects because the function is used inside the body. Now this type is instantiated (via the instantiation algorithm) which simply removes the quantifiers making $\beta^1$, $\delta^2$ and $\beta^3$ free. The type is then pattern matched to obtain the variables $\tau'$ and $\tau''$. Doing as stated above, their value becomes (negative identifiers denote free variables):
\[
\tau' = \forall{}\beta{}^{1}:\mathtt{A}\;{}.\;{}\left(\left(\mathtt{B}\right)^{\beta{}^{1}}\right)\xrightarrow{\delta{}^{-24}*\beta{}^{1}}\left(\mathtt{B}\right)^{\beta{}^{-25}*\beta{}^{1}}
\]

\[
\tau'' = \forall{}\beta{}^{1}:\mathtt{A}\;{}.\;{}\left(\left(\mathtt{B}\right)^{\beta{}^{1}}\right)\xrightarrow{\left\{\left(\textbf{@4},\beta{}^{1}\right);\;{}\left(\textbf{@6},\beta{}^{-23}\right);\;{}\delta{}^{-24}*\textbf{@8}\right\}}\left(\mathtt{B}\right)^{\left\{\beta{}^{-25}*\left\{\right\};\;{}\textbf{@9};\;{}\beta{}^{-25}*\textbf{@8}\right\}}
\]
Theese types are then matched to produce a replacement. Matching proceeds by adding a replacement to the quantified and then the case for arrows of the matching algorithm is reached. Looking at $\tau'$ and $\tau''$, theese are the values of the relevant variables involved in this stage of matching:
\[
\begin{array}{c c}
\delta_0\overline{\chi_i}=\delta{}^{-24}*\beta{}^{1} & \phi = \left\{\left(\textbf{@4},\beta{}^{1}\right);\;{}\left(\textbf{@6},\beta{}^{-23}\right);\;{}\delta{}^{-24}*\textbf{@8}\right\} \\
\beta_0\overline{\beta_j}=\beta{}^{-25}*\beta{}^{1} & \psi_2=\left\{\beta{}^{-25}*\left\{\right\};\;{}\textbf{@9};\;{}\beta{}^{-25}*\textbf{@8}\right\}
\end{array}
\]
At this stage, the substitution $\Omega$ is extended with $\left[\delta^{-24}\to{}\left(\lambda{}\beta{}^{1}:\mathtt{A}\;{}.\;{}\left\{\left(\textbf{@4},\beta{}^{1}\right);\;{}\left(\textbf{@6},\beta{}^{-23}\right);\;{}\delta{}^{-24}*\textbf{@8}\right\}\right)\right]$ and\\ $\left[\beta^{-25}\to{}\left(\lambda{}\beta{}^{1}:\mathtt{A}\;{}.\;{}\left\{\beta{}^{-25}*\left\{\right\};\;{}\textbf{@9};\;{}\beta{}^{-25}*\textbf{@8}\right\}\right)\right]$. Both of theese cases substitute a free variable with an expression that contains the variable. One simple solution seems to be eliminating the exprssions that contain $\delta^{-24}$ and $\beta^{-25}$. For the annotation signature that would give the correct result but for the effect signature, the consumption of {\bf @8} by `some` expression which clearly happens in the expression labeled {\bf @6}. The second alternative one could consider is quantifying over thoose variables which would result with the fixpoint expression:
\[
\mathbf{fix}\;{}\left(\lambda{}x^{1}:\mathtt{B}\to{}\mathtt{B}\;{}.\;{}\left(\lambda{}x^{2}:\mathtt{B}\;{}.\;{}\left(\mathbf{if}\;{}x^{2}\;{}\mathbf{then}\;{}\left(x^{1}*\left(\mathbf{False}\right)^{\mathit{@8}}\right)^{\mathit{@6}}\;{}\mathbf{else}\;{}\left(\mathbf{True}\right)^{\mathit{@9}}\right)^{\mathit{@4}}\right)^{\mathit{@3}}\right)^{\mathit{@2}}
\]
to have type:
\[
\forall{}\delta^{24}:\mathtt{A}\to\mathtt{E}.\forall{}\beta^{25}:\mathtt{A}\to\mathtt{A}.\forall{}\beta{}^{1}:\mathtt{A}\;{}.\;{}\left(\left(\mathtt{B}\right)^{\beta{}^{1}}\right)\xrightarrow{\left\{\left(\textbf{@4},\beta{}^{1}\right);\;{}\left(\textbf{@6},\textbf{@3}\right);\;{}\delta{}^{24}*\textbf{@8}\right\}}\left(\mathtt{B}\right)^{\left\{\beta{}^{25}*\left\{\right\};\;{}\textbf{@9};\;{}\beta{}^{25}*\textbf{@8}\right\}}
\]
The type is equally bad because it introduces poisoning due to the fact that the label {\bf @8} is applied to an arbitrary variable of type $\mathtt{B}\to\mathtt{B}$. If one chooses to replace $\beta^{24}$ with the identity function, the label {\bf @8} will appear as a possible annotation that flows out of the function but the term constructed at {\bf @8} will never flow out of this expression.
\\\\
To solve the problem, consider for a moment what $\beta^{-25}$ and $\delta^{-24}$ mean. They originally represented the action of an arbitrary function, but in this context the function is no longer arbitrary. The function is now the argument of \verb+fix+:
\[
\lambda{}x^{1}:\mathtt{B}\to{}\mathtt{B}\;{}.\;{}\left(\lambda{}x^{2}:\mathtt{B}\;{}.\;{}\left(\mathbf{if}\;{}x^{2}\;{}\mathbf{then}\;{}\left(x^{1}*\left(\mathbf{False}\right)^{\mathit{@8}}\right)^{\mathit{@6}}\;{}\mathbf{else}\;{}\left(\mathbf{True}\right)^{\mathit{@9}}\right)^{\mathit{@4}}\right)^{\mathit{@3}}
\]
which has the annotated type given previously. Of particular interest is the type of the output of the function, namely:
\[
\forall{}\beta{}^{4}:\mathtt{A}\;{}.\;{}\left(\left(\mathtt{B}\right)^{\beta{}^{4}}\right)\xrightarrow{\left\{\left(\textbf{@4},\beta{}^{4}\right);\;{}\left(\textbf{@6},\beta{}^{1}\right);\;{}\delta{}^{2}*\textbf{@8}\right\}}\left(\mathtt{B}\right)^{\left\{\beta{}^{3}*\left\{\right\};\;{}\textbf{@9};\;{}\beta{}^{3}*\textbf{@8}\right\}}
\]
It is important to note that $\beta^{4}$ is the variable that denotes the argument of the recursive call of the function. In this example: $\mathbf{False}^{\mathit{@8}}$. The $\delta^2$ variable denotes the effects induced by the recursive function (ie. the function itself). With this notion it is very easy to determine what $\beta^{3}$ and $\delta^{2}$ ($\beta^{-25}$ and $\delta^{-24}$ respectively) should be:
\begin{itemize}
\item If the annotation signature contains the variable $\beta^{4}$ on it's own, it means that the recursive argument may be returend by the function which means that $\beta^{-25}$ should be the identity function.
\item If the annotation signature does not contain the variable $\beta^{4}$ on it's own, it means that the recursive argument is never returned by the function so $\beta^{-25}$ should be the constant $\emptyset$ function.
\item If the effect signature contains a flow parametrized by $\beta^{4}$ (for example $\left(\mathbf{@4},\beta^{4}\right)$) it means that a recursive call is performed with the element labeled by the flow label as argument. The variable $\delta^{-24}$ should be a function that takes as argumetn an annotation and returns all the flows containing $\beta^4$. In this example: $\delta^{-24}=\lambda\beta:\mathtt{A}.\left(\mathbf{@4},\beta\right)$.
\end{itemize}
If the recursive call takes more than one argument, theese function should be adjusted respectively to discard the annotation variables that don't appear in the corresponding annotation and effect signatures of the recursive functions. With theese adjustments in place, the fixpoint expression now has type:
\[
\forall{}\beta{}^{1}:\mathtt{A}\;{}.\;{}\left(\left(\mathtt{B}\right)^{\beta{}^{1}}\right)\xrightarrow{\left\{\left(\textbf{@4},\textbf{@8}\right);\;{}\left(\textbf{@6},\textbf{@3}\right);\;{}\left(\textbf{@4},\beta{}^{1}\right)\right\}}\left(\mathtt{B}\right)^{\textbf{@9}}
\]
and the whole expression results in:
\[
\begin{array}{c}
\tau=\left(\mathtt{B}\right)^{\textbf{@9}} \\
\phi=\left\{\left(\textbf{@1},\textbf{@2}\right);\;{}\left(\textbf{@4},\textbf{@10}\right);\;{}\left(\textbf{@4},\textbf{@8}\right);\;{}\left(\textbf{@6},\textbf{@3}\right);\;{}\left(\textbf{@0},\textbf{@3}\right)\right\}
\end{array}
\]
\end{document}
